## 静态成员
静态成员就是成员变量、成员函数前加上关键字static，被称为静态成员
静态成员被分为**静态成员变量**与**静态成员函数**

* 静态共享：不用考虑调用者是谁

* 静态成员变量特点：
  * 静态成员变量不属于某个对象上，**所有对象共享同一份数据**
  因此静态成员变量有两种访问方式：通过对象访问 和 通过类名访问
   ```cpp
    class person
    {
    public:
        static int a;   //类内声明
    };

    int person::a = 100;   //okey,在类外初始化了类内的静态成员变量

    int main(){
        person p; //调用默认构造创建一个对象名为p
        std::cout << p.a << std::endl;  //输出为100，静态成员变量a初始化为100
        person p1; //调用默认构造创建一个对象名为p1
        p1.a = 200;

        std::cout << p.a << std::endl;  //输出为200，所有对象共享一份数据！（通过对象访问）

        std::cout << person::a << std::endl;  //通过类名访问静态成员变量
        return 0;
    }
   ```
  * 在编译阶段分配内存（静态变量被分配在全局区）
  * 必须在类内声明，**类外初始化**
  ```cpp
    class person
    {
    public:
        static int a;   //类内声明
    };

    int a = 100;   //error,此处是定义了一个全局变量
    int person::a = 100;   //okey,在类外初始化了类内的静态成员变量

    int main(){
        
        return 0;
    }
  ```
  * 静态成员变量也是有访问权限的（public,protected,public）

* 静态成员函数特点：
  * **所有对象共享同一函数**，因此静态成员函数也有两种访问方式：通过对象访问 和 通过类名访问
  * 静态成员函数**只能**访问静态成员变量
  原因：因为所有对象共享同一份静态成员函数，故若静态成员函数修改了一个非静态成员变量（*假设为m_b*），编译器无法区分该函数到底修改了哪个对象上的m_b属性
  * 静态成员函数也是有访问权限的（public,protected,public）

## 类内的成员变量和成员函数的存储位
  C++中成员变量和成员函数是分开存储的
  **结论：只有非静态成员变量才属于类的对象上**，即静态成员和非静态成员函数不属于类的对象上
  * 注意：编译器给**每个空对象**也分配了**一个字节**的内存空间(独一无二的空间)，为了区分各对象所占内存的位置
